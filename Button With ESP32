<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Button Tutorial with MicroPython</title>
    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --light: #ecf0f1;
            --dark: #2c3e50;
            --success: #2ecc71;
            --warning: #f39c12;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            scroll-behavior: smooth;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 2rem 0;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        h1, h2, h3 {
            margin-bottom: 1rem;
            color: var(--primary);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
        
        h2 {
            font-size: 2rem;
            border-bottom: 2px solid var(--secondary);
            padding-bottom: 0.5rem;
            margin-top: 2rem;
        }
        
        h3 {
            font-size: 1.5rem;
            color: var(--secondary);
        }
        
        p {
            margin-bottom: 1rem;
        }
        
        section {
            background: white;
            border-radius: 8px;
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        .button-explanation {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            align-items: center;
        }
        
        .button-info {
            flex: 1;
            min-width: 300px;
        }
        
        .button-diagram {
            flex: 1;
            min-width: 300px;
            text-align: center;
        }
        
        .button-symbol {
            font-size: 100px;
            color: var(--accent);
            margin-bottom: 1rem;
        }
        
        .projects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        
        .project-card {
            background: var(--light);
            border-radius: 8px;
            padding: 1.5rem;
            transition: transform 0.3s, box-shadow 0.3s;
            border-left: 4px solid var(--secondary);
            cursor: pointer;
        }
        
        .project-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .project-card h3 {
            margin-top: 0;
            color: var(--primary);
        }
        
        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 1.5rem;
            border-radius: 5px;
            overflow-x: auto;
            margin: 1rem 0;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            position: relative;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #444;
        }
        
        .copy-btn {
            background: var(--secondary);
            color: white;
            border: none;
            padding: 0.3rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        .keyword {
            color: #569cd6;
        }
        
        .function {
            color: #dcdcaa;
        }
        
        .string {
            color: #ce9178;
        }
        
        .comment {
            color: #6a9955;
            font-style: italic;
        }
        
        .number {
            color: #b5cea8;
        }
        
        .operator {
            color: #d4d4d4;
        }
        
        .btn {
            display: inline-block;
            background: var(--secondary);
            color: white;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            transition: background 0.3s;
            margin-top: 0.5rem;
        }
        
        .btn:hover {
            background: #2980b9;
        }
        
        .connection-guide {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
        }
        
        .wiring-info {
            flex: 1;
            min-width: 300px;
        }
        
        .wiring-diagram {
            flex: 1;
            min-width: 300px;
            text-align: center;
        }
        
        .esp32-img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        footer {
            background: var(--dark);
            color: white;
            text-align: center;
            padding: 2rem 0;
            margin-top: 2rem;
        }
        
        .project-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 2rem;
            border-radius: 8px;
            width: 90%;
            max-width: 900px;
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .close-modal {
            position: absolute;
            top: 1rem;
            right: 1.5rem;
            font-size: 2rem;
            cursor: pointer;
            color: var(--dark);
            z-index: 10;
        }
        
        .tab-buttons {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        .tab-button {
            padding: 0.5rem 1rem;
            background: none;
            border: none;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
        }
        
        .tab-button.active {
            border-bottom: 2px solid var(--secondary);
            color: var(--secondary);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .function-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }
        
        .function-table th, .function-table td {
            border: 1px solid #ddd;
            padding: 0.8rem;
            text-align: left;
        }
        
        .function-table th {
            background: var(--light);
        }
        
        .function-table tr:nth-child(even) {
            background: #f9f9f9;
        }
        
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 2rem;
        }
        
        .button-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        
        .button-type {
            background: var(--light);
            padding: 1.5rem;
            border-radius: 8px;
            text-align: center;
        }
        
        .button-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        .debounce-explanation {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            align-items: center;
            margin-top: 1.5rem;
        }
        
        .debounce-info {
            flex: 1;
            min-width: 300px;
        }
        
        .debounce-diagram {
            flex: 1;
            min-width: 300px;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            .button-explanation, .connection-guide, .debounce-explanation {
                flex-direction: column;
            }
            
            .projects-grid {
                grid-template-columns: 1fr;
            }
            
            .modal-content {
                width: 95%;
                padding: 1rem;
            }
            
            .tab-buttons {
                flex-direction: column;
            }
            
            .tab-button {
                text-align: left;
                border-bottom: 1px solid #ddd;
            }
            
            .button-types {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>ESP32 Button Tutorial with MicroPython</h1>
            <p>Learn how to connect and program buttons with ESP32 using MicroPython</p>
        </div>
    </header>

    <div class="container">
        <section id="what-is-button">
            <h2>What is a Push Button?</h2>
            <div class="button-explanation">
                <div class="button-info">
                    <p>A <strong>push button</strong> is a simple switch mechanism that controls the flow of electricity in a circuit. When pressed, it completes the circuit, allowing current to flow. When released, it breaks the circuit.</p>
                    <p>Buttons are essential components in electronics projects for:</p>
                    <ul>
                        <li>User input and interaction</li>
                        <li>Controlling devices and functions</li>
                        <li>Triggering actions and events</li>
                        <li>Navigation in interfaces</li>
                    </ul>
                    <p>In ESP32 projects, buttons are typically connected to GPIO pins and read as digital inputs.</p>
                </div>
                <div class="button-diagram">
                    <div class="button-symbol">üîò</div>
                    <p>Push Button Symbol</p>
                    <img src="https://components101.com/sites/default/files/component_pin/Push-Button-Pinout.png" alt="Button Diagram" class="esp32-img">
                </div>
            </div>
        </section>

        <section id="button-types">
            <h2>Types of Buttons</h2>
            <p>Different types of buttons serve various purposes in electronics projects:</p>
            <div class="button-types">
                <div class="button-type">
                    <div class="button-icon">üîò</div>
                    <h3>Momentary Push Button</h3>
                    <p>Most common type. Only active while being pressed. Returns to default state when released.</p>
                </div>
                <div class="button-type">
                    <div class="button-icon">üîí</div>
                    <h3>Latching Push Button</h3>
                    <p>Stays in pressed state until pressed again. Toggles between on and off states.</p>
                </div>
                <div class="button-type">
                    <div class="button-icon">üéõÔ∏è</div>
                    <h3>Tactile Switch</h3>
                    <p>Small buttons with a distinct "click" feedback. Commonly used on PCBs.</p>
                </div>
                <div class="button-type">
                    <div class="button-icon">üîÑ</div>
                    <h3>Rotary Encoder</h3>
                    <p>Can detect rotation and push actions. Used for volume controls, menus, etc.</p>
                </div>
            </div>
        </section>

        <section id="connecting-button">
            <h2>How to Connect Buttons with ESP32</h2>
            <div class="connection-guide">
                <div class="wiring-info">
                    <p>Connecting a button to an ESP32 requires understanding of pull-up and pull-down resistors:</p>
                    
                    <h3>Pull-Up Resistor Configuration</h3>
                    <p>Most common method with ESP32:</p>
                    <ul>
                        <li>Connect one side of the button to a GPIO pin</li>
                        <li>Connect the same side to 3.3V through a resistor (10kŒ© recommended)</li>
                        <li>Connect the other side of the button to GND</li>
                    </ul>
                    
                    <h3>Using Internal Pull-Up Resistor</h3>
                    <p>ESP32 has built-in pull-up resistors that can be enabled in code:</p>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Internal Pull-Up Example</span>
                            <button class="copy-btn" onclick="copyCode(this)">Copy Code</button>
                        </div>
                        <pre><code><span class="comment"># Enable internal pull-up resistor</span>
button = Pin(<span class="number">4</span>, Pin.IN, Pin.PULL_UP)</code></pre>
                    </div>
                    
                    <p><strong>Button States:</strong></p>
                    <ul>
                        <li><strong>Not Pressed:</strong> GPIO reads HIGH (1) due to pull-up resistor</li>
                        <li><strong>Pressed:</strong> GPIO reads LOW (0) as button connects to GND</li>
                    </ul>
                </div>
                <div class="wiring-diagram">
                    <img src="https://randomnerdtutorials.com/wp-content/uploads/2019/01/ESP32-Push-Button-Wiring-Diagram.png" alt="ESP32 Button Connection Diagram" class="esp32-img">
                    <p>ESP32 Button Connection with Pull-Up Resistor</p>
                </div>
            </div>
        </section>

        <section id="micropython-basics">
            <h2>MicroPython Basics for Button Control</h2>
            <p>MicroPython provides simple functions to read button states. Here's a basic example:</p>
            <div class="code-block">
                <div class="code-header">
                    <span>Basic Button Reading Example</span>
                    <button class="copy-btn" onclick="copyCode(this)">Copy Code</button>
                </div>
                <pre><code><span class="keyword">from</span> machine <span class="keyword">import</span> Pin
<span class="keyword">import</span> time

<span class="comment"># Initialize button on GPIO4 with internal pull-up</span>
button = Pin(<span class="number">4</span>, Pin.IN, Pin.PULL_UP)

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">if</span> button.value() == <span class="number">0</span>:  <span class="comment"># Button pressed (LOW due to pull-up)</span>
        print(<span class="string">"Button pressed!"</span>)
    time.sleep(<span class="number">0.1</span>)  <span class="comment"># Small delay to avoid flooding the output</span></code></pre>
            </div>
            
            <h3>Complete MicroPython Functions for Button Control</h3>
            <table class="function-table">
                <thead>
                    <tr>
                        <th>Function/Class</th>
                        <th>Description</th>
                        <th>Example Usage</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>Pin(pin_number, Pin.IN)</code></td>
                        <td>Create a Pin object for input</td>
                        <td><code>button = Pin(4, Pin.IN)</code></td>
                    </tr>
                    <tr>
                        <td><code>Pin.PULL_UP</code></td>
                        <td>Enable internal pull-up resistor</td>
                        <td><code>button = Pin(4, Pin.IN, Pin.PULL_UP)</code></td>
                    </tr>
                    <tr>
                        <td><code>Pin.PULL_DOWN</code></td>
                        <td>Enable internal pull-down resistor</td>
                        <td><code>button = Pin(4, Pin.IN, Pin.PULL_DOWN)</code></td>
                    </tr>
                    <tr>
                        <td><code>Pin.value()</code></td>
                        <td>Read the current pin state (0 or 1)</td>
                        <td><code>state = button.value()</code></td>
                    </tr>
                    <tr>
                        <td><code>time.sleep(seconds)</code></td>
                        <td>Delay execution for specified seconds</td>
                        <td><code>time.sleep(0.5)</code></td>
                    </tr>
                    <tr>
                        <td><code>time.sleep_ms(ms)</code></td>
                        <td>Delay execution for milliseconds</td>
                        <td><code>time.sleep_ms(100)</code></td>
                    </tr>
                    <tr>
                        <td><code>time.ticks_ms()</code></td>
                        <td>Get current time in milliseconds</td>
                        <td><code>start = time.ticks_ms()</code></td>
                    </tr>
                    <tr>
                        <td><code>time.ticks_diff(t1, t2)</code></td>
                        <td>Calculate difference between ticks</td>
                        <td><code>elapsed = time.ticks_diff(t2, t1)</code></td>
                    </tr>
                </tbody>
            </table>
            
            <h3>Button Debouncing</h3>
            <div class="debounce-explanation">
                <div class="debounce-info">
                    <p>Mechanical buttons often produce multiple rapid transitions (bounces) when pressed or released. Debouncing ensures only one press is registered.</p>
                    <p><strong>Software Debouncing Techniques:</strong></p>
                    <ul>
                        <li><strong>Delay-based:</strong> Wait for a short period after detecting a press</li>
                        <li><strong>State-based:</strong> Track button state changes over time</li>
                        <li><strong>Timer-based:</strong> Use timers to detect stable states</li>
                    </ul>
                    <div class="code-block">
                        <div class="code-header">
                            <span>Simple Debouncing Example</span>
                            <button class="copy-btn" onclick="copyCode(this)">Copy Code</button>
                        </div>
                        <pre><code><span class="keyword">from</span> machine <span class="keyword">import</span> Pin
<span class="keyword">import</span> time

button = Pin(<span class="number">4</span>, Pin.IN, Pin.PULL_UP)
last_state = button.value()
last_debounce_time = <span class="number">0</span>
debounce_delay = <span class="number">50</span>  <span class="comment"># milliseconds</span>

<span class="keyword">while</span> <span class="keyword">True</span>:
    current_state = button.value()
    current_time = time.ticks_ms()
    
    <span class="keyword">if</span> current_state != last_state:
        last_debounce_time = current_time
    
    <span class="keyword">if</span> (current_time - last_debounce_time) > debounce_delay:
        <span class="keyword">if</span> current_state == <span class="number">0</span>:
            print(<span class="string">"Button pressed (debounced)"</span>)
    
    last_state = current_state
    time.sleep_ms(<span class="number">10</span>)</code></pre>
                    </div>
                </div>
                <div class="debounce-diagram">
                    <img src="https://www.arduino.cc/en/uploads/Tutorial/button_debounce_timing_diagram.png" alt="Button Debouncing Diagram" class="esp32-img">
                    <p>Button Signal with and without Debouncing</p>
                </div>
            </div>
        </section>

        <section id="button-projects">
            <h2>ESP32 Button Projects with MicroPython</h2>
            <p>Explore these 15 projects that demonstrate various button techniques with ESP32:</p>
            
            <div class="projects-grid">
                <!-- Project cards will be generated by JavaScript -->
            </div>
        </section>
    </div>

    <!-- Project Modal -->
    <div id="projectModal" class="project-modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <div id="modalContent">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <footer>
        <div class="container">
            <p>ESP32 Button Tutorial with MicroPython</p>
            <p>Educational resource for learning electronics and programming</p>
        </div>
    </footer>

    <script>
        // Project data
        const projects = [
            {
                id: 1,
                title: "ESP32 + LED + Button (Toggle)",
                description: "Toggle LED state with each button press",
                idea: "Turn LED on/off with each button press",
                code: `from machine import Pin
import time

led = Pin(2, Pin.OUT)
button = Pin(4, Pin.IN, Pin.PULL_UP)

led_state = 0

while True:
    if button.value() == 0:
        led_state = not led_state
        led.value(led_state)
        time.sleep(0.3)`,
                buttonTechnique: "Basic button reading with state toggling"
            },
            {
                id: 2,
                title: "ESP32 + LED + Button (On/Off)",
                description: "First press turns LED on, second press turns it off",
                idea: "Simple on/off control with a single button",
                code: `from machine import Pin
import time

led = Pin(2, Pin.OUT)
button = Pin(4, Pin.IN, Pin.PULL_UP)

led_on = False

while True:
    if button.value() == 0:
        led_on = not led_on
        led.value(led_on)
        time.sleep(0.3)`,
                buttonTechnique: "Boolean state tracking"
            },
            {
                id: 3,
                title: "ESP32 + LED + 2 Buttons",
                description: "One button turns LED on, the other turns it off",
                idea: "Separate buttons for on and off control",
                code: `from machine import Pin
import time

led = Pin(2, Pin.OUT)
button_on = Pin(4, Pin.IN, Pin.PULL_UP)
button_off = Pin(5, Pin.IN, Pin.PULL_UP)

while True:
    if button_on.value() == 0:
        led.value(1)
        time.sleep(0.2)
    if button_off.value() == 0:
        led.value(0)
        time.sleep(0.2)`,
                buttonTechnique: "Multiple independent button inputs"
            },
            {
                id: 4,
                title: "ESP32 + 2 LED + 2 Buttons",
                description: "Each button controls a separate LED",
                idea: "Independent control of multiple LEDs",
                code: `from machine import Pin
import time

led1 = Pin(2, Pin.OUT)
led2 = Pin(15, Pin.OUT)

button1 = Pin(4, Pin.IN, Pin.PULL_UP)
button2 = Pin(5, Pin.IN, Pin.PULL_UP)

while True:
    if button1.value() == 0:
        led1.value(1)
    else:
        led1.value(0)
    
    if button2.value() == 0:
        led2.value(1)
    else:
        led2.value(0)`,
                buttonTechnique: "Direct button-to-LED mapping"
            },
            {
                id: 5,
                title: "ESP32 + LED + 2 Buttons (Both Pressed)",
                description: "LED turns on only when both buttons are pressed",
                idea: "Require simultaneous button presses",
                code: `from machine import Pin
import time

led = Pin(2, Pin.OUT)
button1 = Pin(4, Pin.IN, Pin.PULL_UP)
button2 = Pin(5, Pin.IN, Pin.PULL_UP)

while True:
    if button1.value() == 0 and button2.value() == 0:
        led.value(1)
    else:
        led.value(0)
    time.sleep(0.1)`,
                buttonTechnique: "Multiple condition checking with AND operator"
            },
            {
                id: 6,
                title: "ESP32 + LED + Button (Increase Brightness)",
                description: "Each button press increases LED brightness using PWM",
                idea: "PWM-based brightness control",
                code: `from machine import Pin, PWM
import time

led = PWM(Pin(2), freq=1000)
button = Pin(4, Pin.IN, Pin.PULL_UP)

brightness = 0
step = 200

while True:
    if button.value() == 0:
        brightness += step
        if brightness > 1023:
            brightness = 0
        led.duty(brightness)
        time.sleep(0.3)`,
                buttonTechnique: "Button-controlled parameter adjustment"
            },
            {
                id: 7,
                title: "ESP32 + 5 LED + Button (Sequential On)",
                description: "Each press turns on the next LED, keeping previous ones on",
                idea: "Sequential LED activation",
                code: `from machine import Pin
import time

leds = [Pin(pin, Pin.OUT) for pin in [2, 15, 18, 19, 21]]
button = Pin(4, Pin.IN, Pin.PULL_UP)

index = 0

while True:
    if button.value() == 0:
        if index < len(leds):
            leds[index].value(1)
            index += 1
        time.sleep(0.3)`,
                buttonTechnique: "Button-controlled indexing"
            },
            {
                id: 8,
                title: "ESP32 + 5 LED + Button (One at a Time)",
                description: "Each press moves the light to the next LED, turning off the previous",
                idea: "Single LED activation at a time",
                code: `from machine import Pin
import time

leds = [Pin(pin, Pin.OUT) for pin in [2, 15, 18, 19, 21]]
button = Pin(4, Pin.IN, Pin.PULL_UP)

index = 0

while True:
    if button.value() == 0:
        for led in leds:
            led.value(0)
        leds[index].value(1)
        index = (index + 1) % len(leds)
        time.sleep(0.3)`,
                buttonTechnique: "Circular indexing with modulus operator"
            },
            {
                id: 9,
                title: "ESP32 + 5 LED + 3 Buttons (Animations)",
                description: "Different buttons trigger different LED animations",
                idea: "Multiple animation modes",
                code: `from machine import Pin
import time

leds = [Pin(pin, Pin.OUT) for pin in [2, 15, 18, 19, 21]]
button1 = Pin(4, Pin.IN, Pin.PULL_UP)
button2 = Pin(5, Pin.IN, Pin.PULL_UP)
button3 = Pin(22, Pin.IN, Pin.PULL_UP)

def all_on():
    for led in leds:
        led.value(1)

def all_off():
    for led in leds:
        led.value(0)

def chase():
    for led in leds:
        all_off()
        led.value(1)
        time.sleep(0.2)

def flash():
    for _ in range(3):
        all_on()
        time.sleep(0.2)
        all_off()
        time.sleep(0.2)

while True:
    if button1.value() == 0:
        all_on()
        time.sleep(0.3)
    elif button2.value() == 0:
        chase()
        time.sleep(0.3)
    elif button3.value() == 0:
        flash()
        time.sleep(0.3)`,
                buttonTechnique: "Mode selection with multiple buttons"
            },
            {
                id: 10,
                title: "ESP32 + 5 LED + 2 Buttons (Counter + Display)",
                description: "Count button presses and display the count on LEDs",
                idea: "Visual counter using LEDs",
                code: `from machine import Pin
import time

leds = [Pin(pin, Pin.OUT) for pin in [2, 15, 18, 19, 21]]
button_count = Pin(4, Pin.IN, Pin.PULL_UP)
button_show = Pin(5, Pin.IN, Pin.PULL_UP)

count = 0

while True:
    if button_count.value() == 0:
        count += 1
        if count > len(leds):
            count = len(leds)
        time.sleep(0.3)
    
    if button_show.value() == 0:
        for i, led in enumerate(leds):
            if i < count:
                led.value(1)
            else:
                led.value(0)
        time.sleep(0.3)`,
                buttonTechnique: "Separate functions for counting and display"
            },
            {
                id: 11,
                title: "ESP32 + 5 LED + Button (Invert All)",
                description: "Each press inverts the state of all LEDs",
                idea: "Toggle all LEDs simultaneously",
                code: `from machine import Pin
import time

leds = [Pin(pin, Pin.OUT) for pin in [2, 15, 18, 19, 21]]
button = Pin(4, Pin.IN, Pin.PULL_UP)

state = 0

while True:
    if button.value() == 0:
        state = not state
        for led in leds:
            led.value(state)
        time.sleep(0.3)`,
                buttonTechnique: "Global state inversion"
            },
            {
                id: 12,
                title: "ESP32 + 5 LED + 2 Buttons (Gradual On/Off)",
                description: "Gradually turn LEDs on/off with separate buttons",
                idea: "Sequential activation/deactivation",
                code: `from machine import Pin
import time

leds = [Pin(pin, Pin.OUT) for pin in [2, 15, 18, 19, 21]]
button_on = Pin(4, Pin.IN, Pin.PULL_UP)
button_off = Pin(5, Pin.IN, Pin.PULL_UP)

while True:
    if button_on.value() == 0:
        for led in leds:
            led.value(1)
            time.sleep(0.2)
    if button_off.value() == 0:
        for led in leds:
            led.value(0)
            time.sleep(0.2)`,
                buttonTechnique: "Sequential control with delays"
            },
            {
                id: 13,
                title: "ESP32 + 5 LED + Button (Running Light)",
                description: "Create a running light effect with LEDs",
                idea: "LED chasing animation",
                code: `from machine import Pin
import time

leds = [Pin(pin, Pin.OUT) for pin in [2, 15, 18, 19, 21]]
button = Pin(4, Pin.IN, Pin.PULL_UP)

while True:
    if button.value() == 0:
        for led in leds:
            for l in leds:
                l.value(0)
            led.value(1)
            time.sleep(0.2)
        time.sleep(0.3)`,
                buttonTechnique: "Button-triggered animation sequence"
            },
            {
                id: 14,
                title: "ESP32 + 5 LED + 2 Buttons (Binary Counter)",
                description: "Binary counter with reset functionality",
                idea: "Display binary numbers using LEDs",
                code: `from machine import Pin
import time

leds = [Pin(pin, Pin.OUT) for pin in [2, 15, 18, 19, 21]]
button_next = Pin(4, Pin.IN, Pin.PULL_UP)
button_reset = Pin(5, Pin.IN, Pin.PULL_UP)

count = 0

while True:
    if button_next.value() == 0:
        count += 1
        if count >= 2**len(leds):
            count = 0
        for i, led in enumerate(leds):
            led.value((count >> i) & 1)
        time.sleep(0.3)
    
    if button_reset.value() == 0:
        count = 0
        for led in leds:
            led.value(0)
        time.sleep(0.3)`,
                buttonTechnique: "Binary operations and bit manipulation"
            },
            {
                id: 15,
                title: "ESP32 + 5 LED + 3 Buttons (Modes)",
                description: "Different buttons activate different LED modes",
                idea: "Multiple lighting modes",
                code: `from machine import Pin
import time
import urandom

leds = [Pin(pin, Pin.OUT) for pin in [2, 15, 18, 19, 21]]
button1 = Pin(4, Pin.IN, Pin.PULL_UP)
button2 = Pin(5, Pin.IN, Pin.PULL_UP)
button3 = Pin(22, Pin.IN, Pin.PULL_UP)

def all_blink():
    for _ in range(3):
        for led in leds: led.value(1)
        time.sleep(0.3)
        for led in leds: led.value(0)
        time.sleep(0.3)

def running_light():
    for led in leds:
        for l in leds: l.value(0)
        led.value(1)
        time.sleep(0.2)

def random_light():
    for _ in range(5):
        r = urandom.getrandbits(3) % len(leds)
        for i, led in enumerate(leds):
            led.value(1 if i == r else 0)
        time.sleep(0.3)

while True:
    if button1.value() == 0:
        all_blink()
        time.sleep(0.3)
    elif button2.value() == 0:
        running_light()
        time.sleep(0.3)
    elif button3.value() == 0:
        random_light()
        time.sleep(0.3)`,
                buttonTechnique: "Complex mode selection with function calls"
            }
        ];

        // Function to create project cards
        function createProjectCards() {
            const projectsGrid = document.querySelector('.projects-grid');
            
            projects.forEach(project => {
                const card = document.createElement('div');
                card.className = 'project-card';
                card.innerHTML = `
                    <h3>Project ${project.id}: ${project.title}</h3>
                    <p>${project.description}</p>
                    <button class="btn view-project" data-id="${project.id}">View Project</button>
                `;
                projectsGrid.appendChild(card);
            });
            
            // Add event listeners to view buttons
            document.querySelectorAll('.view-project').forEach(button => {
                button.addEventListener('click', function() {
                    const projectId = parseInt(this.getAttribute('data-id'));
                    openProjectModal(projectId);
                });
            });
            
            // Also make the entire card clickable
            document.querySelectorAll('.project-card').forEach(card => {
                card.addEventListener('click', function(e) {
                    if (!e.target.classList.contains('btn')) {
                        const button = this.querySelector('.view-project');
                        const projectId = parseInt(button.getAttribute('data-id'));
                        openProjectModal(projectId);
                    }
                });
            });
        }

        // Function to open project modal
        function openProjectModal(projectId) {
            const project = projects.find(p => p.id === projectId);
            if (!project) return;
            
            const modalContent = document.getElementById('modalContent');
            modalContent.innerHTML = `
                <h2>Project ${project.id}: ${project.title}</h2>
                <p><strong>Idea:</strong> ${project.idea}</p>
                <p><strong>Description:</strong> ${project.description}</p>
                
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="code">MicroPython Code</button>
                    <button class="tab-button" data-tab="explanation">Explanation</button>
                    <button class="tab-button" data-tab="components">Components</button>
                    <button class="tab-button" data-tab="technique">Button Technique</button>
                </div>
                
                <div class="tab-content active" id="code-tab">
                    <div class="code-block">
                        <div class="code-header">
                            <span>Project ${project.id} Code</span>
                            <button class="copy-btn" onclick="copyCode(this)">Copy Code</button>
                        </div>
                        <pre><code>${formatCode(project.code)}</code></pre>
                    </div>
                </div>
                
                <div class="tab-content" id="explanation-tab">
                    <h3>How It Works</h3>
                    <p>${getProjectExplanation(project.id)}</p>
                    
                    <h3>Key MicroPython Functions Used</h3>
                    <ul>
                        ${getFunctionsUsed(project.code).map(func => `<li><code>${func}</code></li>`).join('')}
                    </ul>
                </div>
                
                <div class="tab-content" id="components-tab">
                    <h3>Required Components</h3>
                    <ul>
                        <li>ESP32 Development Board</li>
                        <li>${getLEDCount(project.id)}</li>
                        <li>${getButtonCount(project.id)}</li>
                        <li>Resistors (220Œ© recommended for LEDs, 10kŒ© for buttons if not using internal pull-ups)</li>
                        <li>Breadboard and jumper wires</li>
                    </ul>
                    
                    <h3>Connection Guide</h3>
                    <p>${getConnectionGuide(project.id)}</p>
                </div>
                
                <div class="tab-content" id="technique-tab">
                    <h3>Button Technique Used</h3>
                    <p>${project.buttonTechnique}</p>
                    
                    <h3>Technical Details</h3>
                    <p>${getButtonTechniqueDetails(project.id)}</p>
                    
                    <h3>Common Applications</h3>
                    <p>${getButtonApplications(project.id)}</p>
                </div>
                
                <div class="nav-buttons">
                    <button class="btn" onclick="navigateProject(${project.id - 1})" ${project.id === 1 ? 'disabled' : ''}>Previous Project</button>
                    <button class="btn" onclick="navigateProject(${project.id + 1})" ${project.id === projects.length ? 'disabled' : ''}>Next Project</button>
                </div>
            `;
            
            // Add tab functionality
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    
                    // Remove active class from all tabs
                    document.querySelectorAll('.tab-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // Add active class to current tab
                    this.classList.add('active');
                    document.getElementById(`${tabName}-tab`).classList.add('active');
                });
            });
            
            // Show modal
            document.getElementById('projectModal').style.display = 'block';
        }

        // Function to format code with syntax highlighting
        function formatCode(code) {
            return code
                .replace(/from/g, '<span class="keyword">from</span>')
                .replace(/import/g, '<span class="keyword">import</span>')
                .replace(/def/g, '<span class="keyword">def</span>')
                .replace(/while/g, '<span class="keyword">while</span>')
                .replace(/if/g, '<span class="keyword">if</span>')
                .replace(/elif/g, '<span class="keyword">elif</span>')
                .replace(/else/g, '<span class="keyword">else</span>')
                .replace(/for/g, '<span class="keyword">for</span>')
                .replace(/True/g, '<span class="keyword">True</span>')
                .replace(/False/g, '<span class="keyword">False</span>')
                .replace(/Pin\.OUT/g, '<span class="function">Pin.OUT</span>')
                .replace(/Pin\.IN/g, '<span class="function">Pin.IN</span>')
                .replace(/PULL_UP/g, '<span class="function">PULL_UP</span>')
                .replace(/PWM/g, '<span class="function">PWM</span>')
                .replace(/duty/g, '<span class="function">duty</span>')
                .replace(/freq/g, '<span class="function">freq</span>')
                .replace(/value/g, '<span class="function">value</span>')
                .replace(/sleep/g, '<span class="function">sleep</span>')
                .replace(/#.*$/gm, '<span class="comment">$&</span>')
                .replace(/\d+/g, '<span class="number">$&</span>');
        }

        // Function to copy code to clipboard
        function copyCode(button) {
            const codeBlock = button.closest('.code-block').querySelector('code');
            const textArea = document.createElement('textarea');
            textArea.value = codeBlock.textContent;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            
            // Visual feedback
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            setTimeout(() => {
                button.textContent = originalText;
            }, 2000);
        }

        // Helper function to get button count for a project
        function getButtonCount(projectId) {
            switch(projectId) {
                case 1:
                case 2:
                case 6:
                case 7:
                case 8:
                case 11:
                case 13:
                    return '1 button';
                case 3:
                case 10:
                case 12:
                case 14:
                    return '2 buttons';
                case 4:
                case 5:
                case 9:
                case 15:
                    return '3 buttons';
                default:
                    return '1 button';
            }
        }

        // Helper function to get LED count for a project
        function getLEDCount(projectId) {
            if (projectId >= 7) return '5 LEDs';
            if (projectId === 4) return '2 LEDs';
            return '1 LED';
        }

        // Helper function to get project explanation
        function getProjectExplanation(projectId) {
            const explanations = {
                1: "This project demonstrates basic button interaction with an LED. Each time the button is pressed, the LED state toggles (on to off or off to on). The code uses a simple state variable that flips with each button press.",
                2: "Similar to Project 1, but with a more explicit on/off state variable. The LED state is stored as a boolean value that toggles with each button press.",
                3: "This project uses two separate buttons for controlling the LED - one to turn it on and another to turn it off. This provides more direct control over the LED state.",
                4: "Expanding on previous projects, this uses two LEDs controlled by two separate buttons. Each button independently controls its corresponding LED.",
                5: "This project requires both buttons to be pressed simultaneously to turn on the LED. It demonstrates how to check multiple conditions in an if statement.",
                6: "Introduces PWM (Pulse Width Modulation) for controlling LED brightness. Each button press increases the brightness in steps, wrapping around to 0 when maximum brightness is reached.",
                7: "This project sequentially turns on LEDs with each button press. Once an LED is turned on, it stays on until the program is reset.",
                8: "Unlike Project 7, this project only keeps one LED on at a time. Each button press moves the active LED to the next position in sequence.",
                9: "This more complex project offers three different LED animation modes controlled by three different buttons. Each button triggers a different pattern.",
                10: "Implements a counter that increments with one button and displays the count on LEDs with another button. The number of lit LEDs corresponds to the count value.",
                11: "A simple project that inverts the state of all LEDs with each button press. If LEDs are on, they turn off, and vice versa.",
                12: "Creates a gradual lighting effect where LEDs turn on or off sequentially with a small delay between each, creating a smooth transition.",
                13: "Implements a running light animation where LEDs light up one after another in sequence, creating a chasing effect.",
                14: "A binary counter that displays numbers in binary format using the LEDs. One button increments the counter, another resets it to zero.",
                15: "The most complex project with three different lighting modes: blinking all LEDs, running light, and random LED activation."
            };
            
            return explanations[projectId] || "This project demonstrates various button control techniques using MicroPython on the ESP32.";
        }

        // Helper function to get connection guide
        function getConnectionGuide(projectId) {
            if (projectId <= 3) {
                return "Connect the LED to GPIO2 with a current-limiting resistor to GND. Connect the button(s) to the specified GPIO pins. Use internal pull-up resistors by setting Pin.PULL_UP in code, or add external 10kŒ© resistors between the GPIO pins and 3.3V.";
            } else if (projectId <= 6) {
                return "Connect LEDs to the specified GPIO pins with current-limiting resistors to GND. Connect buttons to the specified GPIO pins. Use internal pull-up resistors or external 10kŒ© resistors.";
            } else {
                return "Connect 5 LEDs to GPIO pins 2, 15, 18, 19, and 21 with current-limiting resistors to GND. Connect buttons to the specified GPIO pins. Use internal pull-up resistors or external 10kŒ© resistors.";
            }
        }

        // Helper function to extract functions used in code
        function getFunctionsUsed(code) {
            const functions = new Set();
            
            // Common MicroPython functions
            const commonFuncs = ['Pin', 'PWM', 'value', 'duty', 'sleep', 'time', 'urandom'];
            
            commonFuncs.forEach(func => {
                if (code.includes(func)) {
                    functions.add(func);
                }
            });
            
            return Array.from(functions);
        }

        // Helper function to get button technique details
        function getButtonTechniqueDetails(projectId) {
            const details = {
                1: "Basic digital input reading with state tracking. The button is connected with a pull-up resistor, so it reads HIGH when not pressed and LOW when pressed.",
                2: "Boolean state management. The code uses a boolean variable to track the LED state, which is toggled with each button press.",
                3: "Multiple independent inputs. Each button is read separately, allowing for different actions based on which button is pressed.",
                4: "Direct input-to-output mapping. Each button directly controls a specific LED without complex logic.",
                5: "Multi-condition checking. The code uses the AND operator to require both buttons to be pressed simultaneously.",
                6: "Parameter adjustment via button. The button press modifies a value (brightness) that affects the output.",
                7: "Sequential indexing. The button press increments an index variable that determines which LED to activate.",
                8: "Circular indexing with modulus. The index wraps around using the modulus operator when it reaches the maximum value.",
                9: "Mode selection with conditional statements. Different buttons trigger different functions using if-elif-else structure.",
                10: "Separate counting and display functions. One button increments a counter, another displays the current value.",
                11: "Global state inversion. A single state variable controls all LEDs simultaneously.",
                12: "Sequential control with timing. Buttons trigger sequences of actions with delays between them.",
                13: "Animation triggering. A button press initiates a complete animation sequence.",
                14: "Binary operations. The code uses bit shifting and masking to convert numbers to binary representation.",
                15: "Complex mode selection with function calls. Buttons trigger different animation functions with their own internal logic."
            };
            
            return details[projectId] || "This project demonstrates various button interaction techniques.";
        }

        // Helper function to get button applications
        function getButtonApplications(projectId) {
            const applications = {
                1: "Toggle switches, mode selectors, on/off controls",
                2: "Simple controls, settings toggles, state changes",
                3: "Dual-function controls, menu navigation, yes/no selections",
                4: "Multi-device control, independent settings, channel selection",
                5: "Security features, special commands, multi-key shortcuts",
                6: "Parameter adjustment, volume controls, brightness settings",
                7: "Sequential selection, menu navigation, step-by-step processes",
                8: "Cyclic selection, mode cycling, circular menus",
                9: "Multi-mode devices, function selection, preset choices",
                10: "Counters, measurement devices, quantity selection",
                11: "Global controls, master switches, invert functions",
                12: "Gradual changes, smooth transitions, sequential activation",
                13: "Animation controls, demo modes, visual effects",
                14: "Binary input, numerical displays, coding applications",
                15: "Complex interfaces, multi-function devices, preset modes"
            };
            
            return applications[projectId] || "Button interfaces are used in various applications from simple controls to complex user interfaces.";
        }

        // Function to navigate between projects
        function navigateProject(projectId) {
            if (projectId >= 1 && projectId <= projects.length) {
                openProjectModal(projectId);
            }
        }

        // Close modal when clicking X
        document.querySelector('.close-modal').addEventListener('click', function() {
            document.getElementById('projectModal').style.display = 'none';
        });

        // Close modal when clicking outside
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('projectModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        });

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            createProjectCards();
        });
    </script>
</body>
</html>
